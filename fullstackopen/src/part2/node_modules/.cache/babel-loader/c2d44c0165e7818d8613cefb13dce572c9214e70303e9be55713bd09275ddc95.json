{"ast":null,"code":"/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\nvar util = require('utils-extend');\nvar path = require('path');\nvar fileMatch = require('file-match');\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\nutil.extend(exports, fs);\n\n/**\n * @description\n * Assign node origin methods to fs\n */\nexports.fs = fs;\nexports.fileMatch = fileMatch;\n\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\nexports.mkdir = function (filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n  mode = mode || 511;\n  if (!children) return callback();\n  children = children.split(path.sep);\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n    filepath = path.join(filepath, children[create.count]);\n    fs.mkdir(filepath, mode, function (err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n  create.count = 0;\n  create(root);\n};\n\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\nexports.mkdirSync = function (filepath, mode) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n  if (!children) return;\n  children = children.split(path.sep);\n  children.forEach(function (item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\nexports.writeFile = function (filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback;\n\n  // Create dir first\n  exports.mkdir(dirname, function () {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\nexports.writeFileSync = function (filename, data, options) {\n  var dirname = path.dirname(filename);\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\nexports.copyFile = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n  if (!options.process) {\n    options.encoding = null;\n  }\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function (err, contents) {\n    if (err) return options.done(err);\n    if (options.process) {\n      contents = options.process(contents);\n    }\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\nexports.copyFileSync = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8'\n  }, options || {});\n  var contents;\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n    exports.writeFileSync(destpath, contents, options);\n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\nexports.recurse = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function (err, files) {\n      if (err) return callback(err);\n      files.forEach(function (filename) {\n        var filepath = path.join(dirpath, filename);\n        fs.stat(filepath, function (err, stats) {\n          var relative = path.relative(rootpath, filepath);\n          var flag = filterCb(relative);\n          if (stats.isDirectory()) {\n            recurse(filepath);\n            if (flag) callback(filepath, relative);\n          } else {\n            if (flag) callback(filepath, relative, filename);\n          }\n        });\n      });\n    });\n  }\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\nexports.recurseSync = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function (filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\nexports.rmdirSync = function (dirpath) {\n  exports.recurseSync(dirpath, function (filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n  fs.rmdirSync(dirpath);\n};\n\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\nexports.copySync = function (dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess);\n\n  // Make sure dest root\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function (filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};","map":{"version":3,"names":["fs","require","util","path","fileMatch","checkCbAndOpts","options","callback","isFunction","isObject","noop","getExists","filepath","exists","existsSync","dirname","extend","exports","mkdir","mode","root","children","relative","split","sep","create","count","length","join","err","mkdirSync","forEach","item","writeFile","filename","data","result","writeFileSync","copyFile","srcpath","destpath","encoding","done","process","readFile","contents","copyFileSync","readFileSync","recurse","dirpath","filter","filterCb","rootpath","readdir","files","stat","stats","flag","isDirectory","recurseSync","readdirSync","statSync","rmdirSync","unlinkSync","copySync","noProcess","noProcessCb","newpath","opts"],"sources":["/Users/blakeahalt/Documents/GitHub/Full-Stack-Open-2022/fullstackopen/node_modules/fs/file-system.js"],"sourcesContent":["/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\nvar util = require('utils-extend');\nvar path = require('path');\nvar fileMatch = require('file-match');\n\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\n\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\n\nutil.extend(exports, fs);\n\n/**\n * @description\n * Assign node origin methods to fs\n */\nexports.fs = fs;\n\nexports.fileMatch = fileMatch;\n\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\nexports.mkdir = function(filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children  = path.relative(root, filepath);\n\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n\n  mode = mode || 511;\n\n  if (!children) return callback();\n\n  children = children.split(path.sep);\n\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n\n    filepath = path.join(filepath, children[create.count]);\n\n    fs.mkdir(filepath, mode, function(err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n\n  create.count = 0;\n  create(root);\n};\n\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\nexports.mkdirSync = function(filepath, mode) {\n  var root = getExists(filepath);\n  var children  = path.relative(root, filepath);\n\n  if (!children) return;\n\n  children = children.split(path.sep);\n\n  children.forEach(function(item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\nexports.writeFile = function(filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback;\n\n  // Create dir first\n  exports.mkdir(dirname, function() {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\nexports.writeFileSync = function(filename, data, options) {\n  var dirname = path.dirname(filename);\n\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\nexports.copyFile = function(srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n\n  if (!options.process) {\n    options.encoding = null;\n  }\n\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function(err, contents) {\n    if (err) return options.done(err);\n\n    if (options.process) {\n      contents = options.process(contents);\n    }\n\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\nexports.copyFileSync = function(srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8' \n  }, options || {});\n  var contents;\n\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n\n    exports.writeFileSync(destpath, contents, options);    \n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\nexports.recurse = function(dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function(err, files) {\n      if (err) return callback(err);\n\n      files.forEach(function(filename) {\n        var filepath = path.join(dirpath, filename);\n\n        fs.stat(filepath, function(err, stats) {\n            var relative = path.relative(rootpath, filepath);\n            var flag = filterCb(relative);\n\n            if (stats.isDirectory()) {\n              recurse(filepath);\n              if (flag) callback(filepath, relative);\n            } else {\n              if (flag) callback(filepath, relative, filename);\n            }\n          });\n        });\n    });\n  }\n\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\nexports.recurseSync = function(dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function(filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n\n  recurse(dirpath);\n};\n\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\nexports.rmdirSync = function(dirpath) {\n  exports.recurseSync(dirpath, function(filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n\n  fs.rmdirSync(dirpath);\n};\n\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\nexports.copySync = function(dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess);\n\n  // Make sure dest root\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function(filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}