{"ast":null,"code":"'use strict';\n\nconst each = require('lodash.foreach');\nconst get = require('lodash.get');\nconst merge = require('lodash.merge');\n\n// Function typecheck helper\nconst isFunc = val => typeof val === 'function';\nconst deepPath = function (schema, pathName) {\n  let path;\n  const paths = pathName.split('.');\n  if (paths.length > 1) {\n    pathName = paths.shift();\n  }\n  if (isFunc(schema.path)) {\n    path = schema.path(pathName);\n  }\n  if (path && path.schema) {\n    path = deepPath(path.schema, paths.join('.'));\n  }\n  return path;\n};\nconst plugin = function (schema, options) {\n  options = options || {};\n  const type = options.type || plugin.defaults.type || 'unique';\n  const message = options.message || plugin.defaults.message || 'Error, expected `{PATH}` to be unique. Value: `{VALUE}`';\n\n  // Mongoose Schema objects don't describe default _id indexes\n  // https://github.com/Automattic/mongoose/issues/5998\n  const indexes = [[{\n    _id: 1\n  }, {\n    unique: true\n  }]].concat(schema.indexes());\n\n  // Dynamically iterate all indexes\n  each(indexes, index => {\n    const indexOptions = index[1];\n    if (indexOptions.unique) {\n      const paths = Object.keys(index[0]);\n      each(paths, pathName => {\n        // Choose error message\n        const pathMessage = typeof indexOptions.unique === 'string' ? indexOptions.unique : message;\n\n        // Obtain the correct path object\n        const path = deepPath(schema, pathName) || schema.path(pathName);\n        if (path) {\n          // Add an async validator\n          path.validate(function () {\n            return new Promise(resolve => {\n              const isSubdocument = isFunc(this.ownerDocument);\n              const isQuery = this.constructor.name === 'Query';\n              const parentDoc = isSubdocument ? this.ownerDocument() : this;\n              const isNew = typeof parentDoc.isNew === 'boolean' ? parentDoc.isNew : !isQuery;\n              const conditions = {};\n              if (!isNew && !isQuery && !parentDoc.isModified(pathName)) {\n                return resolve(true);\n              }\n              each(paths, name => {\n                let pathValue;\n\n                // If the doc is a query, this is a findAndUpdate\n                if (isQuery) {\n                  pathValue = get(this, '_update.' + name) || get(this, '_update.$set.' + name);\n                } else {\n                  pathValue = get(this, isSubdocument ? name.split('.').pop() : name);\n                }\n\n                // Wrap with case-insensitivity\n                if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\n                  // Escape RegExp chars\n                  pathValue = pathValue.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n                  pathValue = new RegExp('^' + pathValue + '$', 'i');\n                }\n                conditions[name] = pathValue;\n              });\n              if (!isNew) {\n                // Use conditions the user has with find*AndUpdate\n                if (isQuery) {\n                  each(this._conditions, (value, key) => {\n                    conditions[key] = {\n                      $ne: value\n                    };\n                  });\n                } else if (this._id) {\n                  conditions._id = {\n                    $ne: this._id\n                  };\n                }\n              }\n              if (indexOptions.partialFilterExpression) {\n                merge(conditions, indexOptions.partialFilterExpression);\n              }\n\n              // Obtain the model depending on context\n              // https://github.com/Automattic/mongoose/issues/3430\n              // https://github.com/Automattic/mongoose/issues/3589\n              let model;\n              if (isQuery) {\n                model = this.model;\n              } else if (isSubdocument) {\n                model = this.ownerDocument().model(this.ownerDocument().constructor.modelName);\n              } else if (isFunc(this.model)) {\n                model = this.model(this.constructor.modelName);\n              } else {\n                model = this.constructor.model(this.constructor.modelName);\n              }\n\n              // Is this model a discriminator and the unique index is on the whole collection,\n              // not just the instances of the discriminator? If so, use the base model to query.\n              // https://github.com/Automattic/mongoose/issues/4965\n              // eslint-disable-next-line\n              if (model.baseModelName && (indexOptions.partialFilterExpression === null || indexOptions.partialFilterExpression === undefined)) {\n                model = model.db.model(model.baseModelName);\n              }\n              model.find(conditions).countDocuments((err, count) => {\n                resolve(count === 0);\n              });\n            });\n          }, pathMessage, type);\n        }\n      });\n    }\n  });\n};\nplugin.defaults = {};\n\n// Export the mongoose plugin\nmodule.exports = plugin;","map":{"version":3,"names":["each","require","get","merge","isFunc","val","deepPath","schema","pathName","path","paths","split","length","shift","join","plugin","options","type","defaults","message","indexes","_id","unique","concat","index","indexOptions","Object","keys","pathMessage","validate","Promise","resolve","isSubdocument","ownerDocument","isQuery","constructor","name","parentDoc","isNew","conditions","isModified","pathValue","pop","uniqueCaseInsensitive","replace","RegExp","_conditions","value","key","$ne","partialFilterExpression","model","modelName","baseModelName","undefined","db","find","countDocuments","err","count","module","exports"],"sources":["/Users/blakeahalt/Documents/GitHub/Full-Stack-Open-2022/fullstackopen/src/part5/node_modules/mongoose-unique-validator/index.js"],"sourcesContent":["'use strict';\n\nconst each = require('lodash.foreach');\nconst get = require('lodash.get');\nconst merge = require('lodash.merge');\n\n// Function typecheck helper\nconst isFunc = (val) => typeof val === 'function';\n\nconst deepPath = function(schema, pathName) {\n    let path;\n    const paths = pathName.split('.');\n\n    if (paths.length > 1) {\n        pathName = paths.shift();\n    }\n\n    if (isFunc(schema.path)) {\n        path = schema.path(pathName);\n    }\n\n    if (path && path.schema) {\n        path = deepPath(path.schema, paths.join('.'));\n    }\n\n    return path;\n};\n\nconst plugin = function(schema, options) {\n    options = options || {};\n    const type = options.type || plugin.defaults.type || 'unique';\n    const message = options.message || plugin.defaults.message || 'Error, expected `{PATH}` to be unique. Value: `{VALUE}`';\n\n    // Mongoose Schema objects don't describe default _id indexes\n    // https://github.com/Automattic/mongoose/issues/5998\n    const indexes = [[{ _id: 1 }, { unique: true }]].concat(schema.indexes());\n\n    // Dynamically iterate all indexes\n    each(indexes, (index) => {\n        const indexOptions = index[1];\n\n        if (indexOptions.unique) {\n            const paths = Object.keys(index[0]);\n            each(paths, (pathName) => {\n                // Choose error message\n                const pathMessage = typeof indexOptions.unique === 'string' ? indexOptions.unique : message;\n\n                // Obtain the correct path object\n                const path = deepPath(schema, pathName) || schema.path(pathName);\n\n                if (path) {\n                    // Add an async validator\n                    path.validate(function() {\n                        return new Promise((resolve) => {\n                            const isSubdocument = isFunc(this.ownerDocument);\n                            const isQuery = this.constructor.name === 'Query';\n                            const parentDoc = isSubdocument ? this.ownerDocument() : this;\n                            const isNew = typeof parentDoc.isNew === 'boolean' ? parentDoc.isNew : !isQuery;\n\n                            const conditions = {};\n\n                            if (!isNew && !isQuery && !parentDoc.isModified(pathName)) {\n                                return resolve(true);\n                            }\n\n                            each(paths, (name) => {\n                                let pathValue;\n\n                                // If the doc is a query, this is a findAndUpdate\n                                if (isQuery) {\n                                    pathValue = get(this, '_update.' + name) || get(this, '_update.$set.' + name);\n                                } else {\n                                    pathValue = get(this, isSubdocument ? name.split('.').pop() : name);\n                                }\n\n                                // Wrap with case-insensitivity\n                                if (get(path, 'options.uniqueCaseInsensitive') || indexOptions.uniqueCaseInsensitive) {\n                                    // Escape RegExp chars\n                                    pathValue = pathValue.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n                                    pathValue = new RegExp('^' + pathValue + '$', 'i');\n                                }\n\n                                conditions[name] = pathValue;\n                            });\n\n                            if (!isNew) {\n                                // Use conditions the user has with find*AndUpdate\n                                if (isQuery) {\n                                    each(this._conditions, (value, key) => {\n                                        conditions[key] = { $ne: value };\n                                    });\n                                } else if (this._id) {\n                                    conditions._id = { $ne: this._id };\n                                }\n                            }\n\n                            if (indexOptions.partialFilterExpression) {\n                                merge(conditions, indexOptions.partialFilterExpression);\n                            }\n\n                            // Obtain the model depending on context\n                            // https://github.com/Automattic/mongoose/issues/3430\n                            // https://github.com/Automattic/mongoose/issues/3589\n                            let model;\n                            if (isQuery) {\n                                model = this.model;\n                            } else if (isSubdocument) {\n                                model = this.ownerDocument().model(this.ownerDocument().constructor.modelName);\n                            } else if (isFunc(this.model)) {\n                                model = this.model(this.constructor.modelName);\n                            } else {\n                                model = this.constructor.model(this.constructor.modelName);\n                            }\n\n                            // Is this model a discriminator and the unique index is on the whole collection,\n                            // not just the instances of the discriminator? If so, use the base model to query.\n                            // https://github.com/Automattic/mongoose/issues/4965\n                            // eslint-disable-next-line\n                            if (model.baseModelName && (indexOptions.partialFilterExpression === null || indexOptions.partialFilterExpression === undefined)) {\n                                model = model.db.model(model.baseModelName);\n                            }\n\n                            model.find(conditions).countDocuments((err, count) => {\n                                resolve(count === 0);\n                            });\n                        });\n                    }, pathMessage, type);\n                }\n            });\n        }\n    });\n};\n\nplugin.defaults = {};\n\n// Export the mongoose plugin\nmodule.exports = plugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}